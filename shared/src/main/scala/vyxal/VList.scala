package vyxal

import collection.mutable.ArrayBuffer

/** A Vyxal list. It could represent a completely evaluated list, a finite list
  * that is in the process of being evaluated, or an infinite list.
  * @param initial
  *   Elements of this list that have already been generated. This should be a
  *   finite list.
  * @param rest
  *   An `Iterator` providing the rest of the list.
  */
class VList(
    initial: Seq[VAny],
    private val rest: Iterator[VAny] = Iterator.empty
) extends Seq[VAny] {

  /** An `ArrayBuffer` containing elements already generated by rest
    */
  private val generated = initial.to(ArrayBuffer)

  /** Get another element from the iterator and add it to the list of generated
    * elements.
    */
  private def getNext(): VAny = {
    val next = rest.next
    generated += next
    next
  }

  def foldl(start: VAny)(op: (VAny, VAny) => VAny): VAny =
    this.fold(start)(op)

  def vmap(f: SimpleMonad): VList = ???

  /** Zip two VLists together with a function. If one is longer than the other,
    * keep the longer one's elements as-is.
    */
  def zipWith(other: VList)(f: (VAny, VAny) => VAny): VList = {
    val it1 = this.iterator
    val it2 = other.iterator

    VList(
      Seq.empty,
      new scala.collection.Iterator[VAny] {
        def hasNext: Boolean = it1.hasNext || it2.hasNext
        def next: VAny =
          if (it1.hasNext && it2.hasNext) f(it1.next, it2.next)
          else if (it1.hasNext && !it2.hasNext) it1.next
          else if (!it1.hasNext && it2.hasNext) it2.next
          else throw Error("Zipwith iterator is already empty")
      }
    )
  }

  /** Set the element at index `ind` to value `value`
    */
  def update(ind: Int, value: VAny): Unit = {}

  /** Get the element at index `ind`
    */
  override def apply(ind: Int): VAny =
    if (ind < 0) {
      throw IndexOutOfBoundsException(s"Index $ind is negative")
    } else if (ind < generated.size) {
      initial(ind)
    } else {
      var i = generated.size
      while (i < ind && rest.hasNext) getNext()
      if (i == ind) generated(i)
      else throw IndexOutOfBoundsException(s"Index $ind greater than size $i")
    }

  override def iterator: Iterator[VAny] = generated.iterator ++ rest

  /** Get the length of this `VList`. A word of caution: this fully evaluates
    * the list, meaning that it won't work with infinite iterators.
    */
  override def length: Int = {
    while (rest.hasNext) getNext()
    generated.size
  }
}

object VList {

  /** Zip multiple VLists together with a function.
    */
  def zipMulti(lists: Seq[VList])(f: Seq[VAny] => VAny): VList = {
    val its = lists.map(_.iterator)

    VList(
      Seq.empty,
      new scala.collection.Iterator[VAny] {
        def hasNext: Boolean = its.exists(_.hasNext)
        def next: VAny = f(its.collect { case it if it.hasNext => it.next })
      }
    )
  }

  /** This lets us pattern match on `VList`s, silly as the implementation may
    * be.
    */
  def unapplySeq(vlist: VList): VList = vlist
}
